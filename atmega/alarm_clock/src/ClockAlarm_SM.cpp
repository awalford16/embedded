//$file${HSM::./src::ClockAlarm_SM.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: ClockAlarm.qm
// File:  ${HSM::./src::ClockAlarm_SM.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open source software: you can redistribute it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// NOTE:
// Alternatively, this generated code may be distributed under the terms
// of Quantum Leaps commercial licenses, which expressly supersede the GNU
// General Public License and are specifically designed for licensees
// interested in retaining the proprietary status of their code.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${HSM::./src::ClockAlarm_SM.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <Arduino.h>
#include "qpn.h"
#include "lcd.h"
#include "ClockAlarm_SM.h"
//$declare${HSM::Clock_Alarm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${HSM::Clock_Alarm} ........................................................
typedef struct Clock_Alarm
{
    // protected:
    QHsm super;

    // private:
    uint32_t temp_time;
    uint8_t alarm_status;
    uint32_t alarm_time;

    // public:
    uint8_t time_mode;

    // private:

    // private state histories
    QStateHandler hist_Clock;
} Clock_Alarm;

extern uint32_t Clock_Alarm_current_time;

extern Clock_Alarm Clock_Alarm_obj;

// public:
static uint32_t Clock_Alarm_get_current_time(void);
static void Clock_Alarm_update_current_time(void);
static void Clock_Alarm_set_current_time(uint32_t new_time);

// protected:
static QState Clock_Alarm_initial(Clock_Alarm *const me, void const *const par);
static QState Clock_Alarm_Clock(Clock_Alarm *const me, QEvt const *const e);
static QState Clock_Alarm_Ticking(Clock_Alarm *const me, QEvt const *const e);
static QState Clock_Alarm_Settings(Clock_Alarm *const me, QEvt const *const e);
static QState Clock_Alarm_ClockSetting(Clock_Alarm *const me, QEvt const *const e);
static QState Clock_Alarm_AlarmSetting(Clock_Alarm *const me, QEvt const *const e);
static QState Clock_Alarm_AlarmNotify(Clock_Alarm *const me, QEvt const *const e);
//$enddecl${HSM::Clock_Alarm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
// #if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
// #error qpc version 7.3.0 or higher required
// #endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${HSM::Clock_Alarm_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${HSM::Clock_Alarm_ctor} ...................................................
void Clock_Alarm_ctor(void)
{
    QHsm_ctor(&Clock_Alarm_obj.super, Q_STATE_CAST(&Clock_Alarm_initial));
}
//$enddef${HSM::Clock_Alarm_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${HSM::Clock_Alarm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${HSM::Clock_Alarm} ........................................................
uint32_t Clock_Alarm_current_time;
Clock_Alarm Clock_Alarm_obj;

//${HSM::Clock_Alarm::update_current_time} ...................................
static void Clock_Alarm_update_current_time(void)
{
    if (++Clock_Alarm_current_time == MAX_TIME)
    {
        Clock_Alarm_current_time = 0;
    }
}

//${HSM::Clock_Alarm::set_current_time} ......................................
static void Clock_Alarm_set_current_time(uint32_t new_time)
{
    // Firstly disable the interrupt as it is sharing the variable
    uint8_t save_sreg = SREG;

    // Disable interrupt
    cli();

    // Update time
    Clock_Alarm_current_time = new_time;

    // Re-enable the interrupt
    SREG = save_sreg;
}

//${HSM::Clock_Alarm::SM} ....................................................
static QState Clock_Alarm_initial(Clock_Alarm *const me, void const *const par)
{
    //${HSM::Clock_Alarm::SM::initial}
    Clock_Alarm_set_current_time(INITIAL_CURRENT_TIME);
    me->alarm_time = INITIAL_ALARM_TIME;
    me->time_mode = MODE_12H;
    me->alarm_status = ALARM_OFF;
    // state history attributes
    me->hist_Clock = Q_STATE_CAST(&Clock_Alarm_Ticking);
    return Q_TRAN(&Clock_Alarm_Ticking);
}

//${HSM::Clock_Alarm::SM::Clock} .............................................
static QState Clock_Alarm_Clock(Clock_Alarm *const me, QEvt const *const e)
{
    QState status_;
    switch (e->sig)
    {
    //${HSM::Clock_Alarm::SM::Clock}
    case Q_EXIT_SIG:
    {
        // save deep history
        me->hist_Clock = QHsm_state(Q_HSM_UPCAST(me));
        status_ = Q_HANDLED();
        break;
    }
    //${HSM::Clock_Alarm::SM::Clock::ALARM}
    case ALARM_SIG:
    {
        status_ = Q_TRAN(&Clock_Alarm_AlarmNotify);
        break;
    }
    default:
    {
        status_ = Q_SUPER(&QHsm_top);
        break;
    }
    }
    return status_;
}

//${HSM::Clock_Alarm::SM::Clock::Ticking} ....................................
static QState Clock_Alarm_Ticking(Clock_Alarm *const me, QEvt const *const e)
{
    QState status_;
    switch (e->sig)
    {
    //${HSM::Clock_Alarm::SM::Clock::Ticking::SET}
    case SET_SIG:
    {
        status_ = Q_TRAN(&Clock_Alarm_ClockSetting);
        break;
    }
    //${HSM::Clock_Alarm::SM::Clock::Ticking::OK}
    case OK_SIG:
    {
        status_ = Q_TRAN(&Clock_Alarm_AlarmSetting);
        break;
    }
    default:
    {
        status_ = Q_SUPER(&Clock_Alarm_Clock);
        break;
    }
    }
    return status_;
}

//${HSM::Clock_Alarm::SM::Clock::Settings} ...................................
static QState Clock_Alarm_Settings(Clock_Alarm *const me, QEvt const *const e)
{
    QState status_;
    switch (e->sig)
    {
    //${HSM::Clock_Alarm::SM::Clock::Settings::ABRT}
    case ABRT_SIG:
    {
        status_ = Q_TRAN(&Clock_Alarm_Ticking);
        break;
    }
    //${HSM::Clock_Alarm::SM::Clock::Settings::OK}
    case OK_SIG:
    {
        status_ = Q_TRAN(&Clock_Alarm_Ticking);
        break;
    }
    default:
    {
        status_ = Q_SUPER(&Clock_Alarm_Clock);
        break;
    }
    }
    return status_;
}

//${HSM::Clock_Alarm::SM::Clock::Settings::ClockSetting} .....................
static QState Clock_Alarm_ClockSetting(Clock_Alarm *const me, QEvt const *const e)
{
    QState status_;
    switch (e->sig)
    {
    default:
    {
        status_ = Q_SUPER(&Clock_Alarm_Settings);
        break;
    }
    }
    return status_;
}

//${HSM::Clock_Alarm::SM::Clock::Settings::AlarmSetting} .....................
static QState Clock_Alarm_AlarmSetting(Clock_Alarm *const me, QEvt const *const e)
{
    QState status_;
    switch (e->sig)
    {
    default:
    {
        status_ = Q_SUPER(&Clock_Alarm_Settings);
        break;
    }
    }
    return status_;
}

//${HSM::Clock_Alarm::SM::AlarmNotify} .......................................
static QState Clock_Alarm_AlarmNotify(Clock_Alarm *const me, QEvt const *const e)
{
    QState status_;
    switch (e->sig)
    {
    //${HSM::Clock_Alarm::SM::AlarmNotify::OK}
    case OK_SIG:
    {
        status_ = Q_TRAN_HIST(me->hist_Clock);
        break;
    }
    default:
    {
        status_ = Q_SUPER(&QHsm_top);
        break;
    }
    }
    return status_;
}
//$enddef${HSM::Clock_Alarm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ISR(TIMER1_COMPA_vect)
{
    Clock_Alarm_update_current_time();
}
